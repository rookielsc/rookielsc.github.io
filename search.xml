<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Log-pilot日志采集收集java堆栈异常日志</title>
    <url>/2021/03/08/log-pilot/</url>
    <content><![CDATA[<span id="more"></span>

<p>一、前言<br>       微服务应用发展迅速，建立一套集中式日志收集系统，将所有节点上的日志统一收集、管理、访问，将极大提高定位问题的效率。</p>
<p> 二、k8s集群日志收集方案<br>       在测试环境部署了log-polit+elk的方案；部署完成之后，日志系统收集java多行异常日志，存在kibana分行的现象，如下图所示；<br><img src="https://img-blog.csdnimg.cn/20200522145219720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDA4Mjk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>三、配置Log-polit<br>1）经过多次的测试，Fliebeat需要更改配置才能处理跨多行日志。使用Log-pilot组件，采集插件支持Filebeat、Fluentd两种，Log-Pilot 能够自动感知宿主机上容器的创建删除事件，进而动态配置容器日志采集配置文件，因此Filebeat、Fluentd的采集配置是有固定模板，配置则需要在Log-poilt打包镜像前配置。<br> 2）本人使用的版本为：log-pilot:v0.9.7-filebeat， log-polit官方源码：<a href="https://github.com/AliyunContainerService/log-pilot.git">https://github.com/AliyunContainerService/log-pilot.git</a> ，通过git clone 下载到本地，在filebeat.tpl文件中添加红框中的的参数，如下图所示<br><img src="https://img-blog.csdnimg.cn/20200522151832176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDA4Mjk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code> 参数详情：
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multiline.pattern: &#39;^\[&#39;   	  &#x2F;&#x2F; 匹配是将多行日志所有不是以[符号开头的行合并成一行</span><br><span class="line">multiline.negate: true		 &#x2F;&#x2F;  是否需要对pattern条件转置使用，不翻转设为true，反转设置为false</span><br><span class="line">multiline.match: after 		&#x2F;&#x2F;   匹配pattern后，与前面（before）还是后面（after）的内容合并为一条日志</span><br></pre></td></tr></table></figure>
<p>3）使用代码库的Dockerfile重新生成镜像、部署，kibana显示的日志合并为一行，如下图。<br><img src="https://img-blog.csdnimg.cn/20200522152601655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDA4Mjk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Kubernetes专栏</category>
      </categories>
      <tags>
        <tag>log-pilot</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署MongoDB分片+副本集集群(实战)</title>
    <url>/2021/02/24/mongodb-cloud/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本次实践部署mongodb集群，<br>主要借鉴于该博客（<a href="https://blog.csdn.net/weixin_42104521/article/details/103731266%EF%BC%89%E3%80%82">https://blog.csdn.net/weixin_42104521/article/details/103731266）。</a></p>
<h1 id="一、原理简析"><a href="#一、原理简析" class="headerlink" title="一、原理简析"></a>一、原理简析</h1><p>Mongodb一共有三种集群搭建的方式：<br>Replica Set（副本集）、<br>Sharding（切片）<br>Master-Slaver（主从）<br><I--more--></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mongoDB目前已不推荐使用主从模式，取而代之的是副本集模式。副本集其实一种互为主从的关系，可理解为主主。<br>enbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;副本集：指将数据复制，多份保存，不同服务器保存同一份数据，在出现故障时自动切换。对应的是数据冗余、备份、镜像、读写分离、高可用性等关键词；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分片：则指为处理大量数据，将数据分开存储，不同服务器保存不同的数据，它们的数据总和即为整个数据集。追求的是高性能。</p>
<h2 id="本实验模拟的MongoDB集群分以下几个层次或角色"><a href="#本实验模拟的MongoDB集群分以下几个层次或角色" class="headerlink" title="本实验模拟的MongoDB集群分以下几个层次或角色"></a>本实验模拟的MongoDB集群分以下几个层次或角色</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongos层：请求的入口，是router的角色，相当于监听，负责将请求分发到对应的存储数据的shard上，多副本冗余</span><br><span class="line"></span><br><span class="line">config server层：记录了mongos中使用到的元数据，自动向mongos同步最新的集群配置，多副本冗余</span><br><span class="line"></span><br><span class="line">shard主节点层：将数据分片，数据库拆分，并将其分散在不同的机器上，原理是将整个数据集合切块</span><br><span class="line">块分散到各个shard中，每个shard只负责总数据的一部分，通过一个均衡器来对各个shard均衡，多副本冗余</span><br><span class="line"></span><br><span class="line">shard副本层：是shard的备份，多副本冗余</span><br><span class="line"></span><br><span class="line">shard仲裁层：用于仲裁，不存储数据，使用最小的资源，需要基数个仲裁角色，且不能放在同一设备上</span><br></pre></td></tr></table></figure>

<h2 id="主机角色端口规划"><a href="#主机角色端口规划" class="headerlink" title="主机角色端口规划"></a>主机角色端口规划</h2><table>
<thead>
<tr>
<th>服务器</th>
<th>192.168.1.32</th>
<th>192.168.1.33</th>
<th>192.168.1.35</th>
</tr>
</thead>
<tbody><tr>
<td>服务端口</td>
<td>mongos:27017</td>
<td>mongos:27017</td>
<td>mongos:27017</td>
</tr>
<tr>
<td>服务端口</td>
<td>config server:9001</td>
<td>config server:9001</td>
<td>config server:9001</td>
</tr>
<tr>
<td>服务端口</td>
<td>shard1 主节点:9005</td>
<td>shard1 副节点:9005</td>
<td>shard1 仲裁节点:9005</td>
</tr>
<tr>
<td>服务端口</td>
<td>shard2 仲裁节点:9006</td>
<td>shard2 主节点:9006</td>
<td>shard2 副节点:9006</td>
</tr>
<tr>
<td>服务端口</td>
<td>shard3 副节点:9007</td>
<td>shard3 仲裁节点:9007</td>
<td>shard3 主节点:9007</td>
</tr>
</tbody></table>
<p>可以看到每台主机上有1个mongos、1个config server、3个分片，三台主机的相同分片之间构成了主、副和仲裁三个角色。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">应用请求mongos来操作mongodb的增删改查</span><br><span class="line">配置服务器存储数据库元信息，并且和mongos做同步</span><br><span class="line">数据最终存入在shard（分片）上</span><br><span class="line">为了防止数据丢失同步在副本集中存储了一份</span><br><span class="line">仲裁在数据存储到分片的时候决定存储到哪个节点</span><br></pre></td></tr></table></figure>

<h1 id="二、部署配置服务器"><a href="#二、部署配置服务器" class="headerlink" title="二、部署配置服务器"></a>二、部署配置服务器</h1><h2 id="创建挂载目录、配置文件"><a href="#创建挂载目录、配置文件" class="headerlink" title="创建挂载目录、配置文件"></a>创建挂载目录、配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /data/mongod/configdata/configsvr -p   //三台主机都执行</span><br><span class="line">mkdir /data/mongod/conf/&#123;configsvr,keyfile&#125; -p   // keyfile在开启用户认证时需要</span><br></pre></td></tr></table></figure>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /data/mongod/conf/configsvr/mongod.conf</span></span><br><span class="line">net:</span><br><span class="line">  bindIpAll: <span class="literal">true</span></span><br><span class="line">replication:</span><br><span class="line">  replSetName: rs_configsvr <span class="comment"># 副本集名称，相同副本须使用同一个副本集名称</span></span><br><span class="line">  </span><br><span class="line">sharding: </span><br><span class="line">   clusterRole: configsvr   <span class="comment"># 定义为mongo配置服务器</span></span><br></pre></td></tr></table></figure>

<h2 id="启动configsvr"><a href="#启动configsvr" class="headerlink" title="启动configsvr"></a>启动configsvr</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 三台主机均执行此操作</span></span><br><span class="line">docker run -d -p 9001:27019 --name configsvr \</span><br><span class="line">  --entrypoint <span class="string">&quot;mongod&quot;</span> \</span><br><span class="line">  -v /data/mongod/configdata/configsvr:/data/configdb \</span><br><span class="line">  -v /data/mongod/conf/keyfile:/data/keyfile \</span><br><span class="line">  -v /data/mongod/conf/configsvr:/data/conf \</span><br><span class="line">  mongo:4.0.21 -f /data/conf/mongod.conf</span><br></pre></td></tr></table></figure>
<p>备注：如果docker ps 没有刚才创建的容器名称，可以使用docker logs &lt;容器id&gt;查看docker 日志</p>
<h2 id="初始化配置服务复制集"><a href="#初始化配置服务复制集" class="headerlink" title="初始化配置服务复制集"></a>初始化配置服务复制集</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入容器中，创建的三个配置服务中随便一个</span></span><br><span class="line">docker <span class="built_in">exec</span> -it configsvr bash</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 登录mongo</span></span><br><span class="line">mongo --host 192.168.1.32 --port 9001</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">use admin</span><br><span class="line">rs.initiate(&#123;</span><br><span class="line">    _id: <span class="string">&quot;rs_configsvr&quot;</span>,</span><br><span class="line">    configsvr: <span class="literal">true</span>,</span><br><span class="line">    members: [</span><br><span class="line">            &#123; _id : 0, host : <span class="string">&quot;192.168.1.32:9001&quot;</span> &#125;,</span><br><span class="line">            &#123; _id : 1, host : <span class="string">&quot;192.168.1.33:9001&quot;</span> &#125;,</span><br><span class="line">            &#123; _id : 2, host : <span class="string">&quot;192.168.1.35:9001&quot;</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rs.status()   //查看状态</span><br></pre></td></tr></table></figure>
<h1 id="三、创建分片副本集"><a href="#三、创建分片副本集" class="headerlink" title="三、创建分片副本集"></a>三、创建分片副本集</h1><h2 id="创建分片副本集配置文件、挂载文件"><a href="#创建分片副本集配置文件、挂载文件" class="headerlink" title="创建分片副本集配置文件、挂载文件"></a>创建分片副本集配置文件、挂载文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 创建配置文件、数据目录</span></span><br><span class="line">mkdir /data/mongod/shard1/&#123;<span class="built_in">log</span>,db&#125; -p</span><br><span class="line">mkdir /data/mongod/shard2/&#123;<span class="built_in">log</span>,db&#125; -p</span><br><span class="line">mkdir /data/mongod/shard3/&#123;<span class="built_in">log</span>,db&#125; -p</span><br><span class="line">chmod -R 777 /data/mongod/shard1</span><br><span class="line">chmod -R 777 /data/mongod/shard2</span><br><span class="line">chmod -R 777 /data/mongod/shard3</span><br><span class="line">mkdir -p /data/mongod/conf/&#123;shard1,shard2,shard3&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## 三台主机均创建三个配置文件，shard分片名不同即可</span></span><br><span class="line"><span class="comment">#所有用到的文件夹和文件必须在创建的时候给权限，包括重新创建，也需要重新给权限，并且文件夹要提前创建好</span></span><br><span class="line"><span class="comment"># vim /data/mongod/conf/&#123;shard1,shard2,shard3&#125;/mongod.conf   //添加如下配置信息，分片服务名称不一致即可</span></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /home/mongod/db <span class="comment">#分片数据库路径</span></span><br><span class="line">  journal:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">  directoryPerDB: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: <span class="literal">true</span></span><br><span class="line">  path: /home/mongod/<span class="built_in">log</span>/mongod.log <span class="comment"># 分片日志</span></span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">  bindIpAll: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">setParameter:</span><br><span class="line">  enableLocalhostAuthBypass: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">  replSetName: rs_shardsvr1  <span class="comment"># 分片服务名称</span></span><br><span class="line"> </span><br><span class="line">sharding: </span><br><span class="line">   clusterRole: shardsvr     <span class="comment"># 配置为分片服务</span></span><br></pre></td></tr></table></figure>
<p>注意事项：<br>1、需要提前建立需要的文件夹。并赋予权限（chmod -R 750 文件夹）。<br>2、三个分片服务器建立在三个位置，（docker代码 -v 参数即为实际建立需要的文件夹），需要注意对应创建分片配置文件，文件内容一致。<br>3、注意配置文件中的数据库文件报错路径以及日志文件路径，按需更改。<br>4、分片服务端口需要映射 27018</p>
<h2 id="shard1-分片"><a href="#shard1-分片" class="headerlink" title="shard1 分片"></a>shard1 分片</h2><h3 id="1、mongod分片部署"><a href="#1、mongod分片部署" class="headerlink" title="1、mongod分片部署"></a>1、mongod分片部署</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 三台主机（192.168.1.32、33、35）执行如下启动命令</span></span><br><span class="line">docker run --name shardsvr1 -d -p 9005:27018 \</span><br><span class="line">  --entrypoint <span class="string">&quot;mongod&quot;</span> \</span><br><span class="line">  -v /data/mongod/shard1:/home/mongod \</span><br><span class="line">  -v /data/mongod/conf/keyfile/:/data/keyfile/ \</span><br><span class="line">  -v /data/mongod/conf/shard1/:/data/conf/ \</span><br><span class="line">  mongo:4.0.21 -f /data/conf/mongod.conf</span><br></pre></td></tr></table></figure>

<h3 id="2、初始化分片服务器"><a href="#2、初始化分片服务器" class="headerlink" title="2、初始化分片服务器"></a>2、初始化分片服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录进容器中，任意一台</span></span><br><span class="line">docker <span class="built_in">exec</span> -it shardsvr1 bash</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 登录分片服务器</span></span><br><span class="line"><span class="comment"># 192.168.1.32 主分片节点</span></span><br><span class="line"><span class="comment"># 192.168.1.33 副分片节点</span></span><br><span class="line"><span class="comment"># 192.168.1.35 仲裁分片节点，arbiterOnly:true 表示为仲裁节点</span></span><br><span class="line"></span><br><span class="line">mongo --host 192.168.1.32 --port 9005</span><br><span class="line">use admin</span><br><span class="line">rs.initiate(</span><br><span class="line">    &#123;</span><br><span class="line">        _id : <span class="string">&quot;rs_shardsvr1&quot;</span>,</span><br><span class="line">        members: [</span><br><span class="line">            &#123; _id : 0, host : <span class="string">&quot;192.168.1.32:9005&quot;</span>,priority:5 &#125;,</span><br><span class="line">            &#123; _id : 1, host : <span class="string">&quot;192.168.1.33:9005&quot;</span>,priority:3 &#125;,</span><br><span class="line">            &#123; _id : 2, host : <span class="string">&quot;192.168.1.35:9005&quot;</span>,arbiterOnly:<span class="literal">true</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#rs.status() 查看状态</span></span><br></pre></td></tr></table></figure>

<h2 id="shard2-分片"><a href="#shard2-分片" class="headerlink" title="shard2 分片"></a>shard2 分片</h2><h3 id="1、mongod分片部署-1"><a href="#1、mongod分片部署-1" class="headerlink" title="1、mongod分片部署"></a>1、mongod分片部署</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 三台主机（192.168.1.32、33、35）执行如下启动命令</span></span><br><span class="line">docker run --name shardsvr2 -d -p 9006:27018 \</span><br><span class="line">  --entrypoint <span class="string">&quot;mongod&quot;</span> \</span><br><span class="line">  -v /data/mongod/shard2:/home/mongod \</span><br><span class="line">  -v /data/mongod/conf/keyfile/:/data/keyfile/ \</span><br><span class="line">  -v /data/mongod/conf/shard2/:/data/conf/ \</span><br><span class="line">  mongo:4.0.21 -f /data/conf/mongod.conf</span><br></pre></td></tr></table></figure>
<h3 id="2、初始化分片服务器-1"><a href="#2、初始化分片服务器-1" class="headerlink" title="2、初始化分片服务器"></a>2、初始化分片服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录进容器中,尽量在主节点执行，否则会报错</span></span><br><span class="line">docker <span class="built_in">exec</span> -it shardsvr2 bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#登录分片服务器</span></span><br><span class="line"><span class="comment"># 192.168.1.32 仲裁分片节点</span></span><br><span class="line"><span class="comment"># 192.168.1.33 主分片节点</span></span><br><span class="line"><span class="comment"># 192.168.1.35 副分片节点</span></span><br><span class="line"></span><br><span class="line">mongo --host 192.168.1.33 --port 9006</span><br><span class="line">use admin</span><br><span class="line">rs.initiate(</span><br><span class="line">    &#123;</span><br><span class="line">        _id : <span class="string">&quot;rs_shardsvr2&quot;</span>,</span><br><span class="line">        members: [</span><br><span class="line">            &#123; _id : 0, host : <span class="string">&quot;192.168.1.32:9006&quot;</span>,arbiterOnly:<span class="literal">true</span> &#125;,</span><br><span class="line">            &#123; _id : 1, host : <span class="string">&quot;192.168.1.33:9006&quot;</span>,priority:5 &#125;,</span><br><span class="line">            &#123; _id : 2, host : <span class="string">&quot;192.168.1.35:9006&quot;</span>,priority:3 &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#rs.status() 查看状态</span></span><br></pre></td></tr></table></figure>

<h2 id="shard3-分片"><a href="#shard3-分片" class="headerlink" title="shard3 分片"></a>shard3 分片</h2><h3 id="1、mongod分片部署-2"><a href="#1、mongod分片部署-2" class="headerlink" title="1、mongod分片部署"></a>1、mongod分片部署</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 三台主机（192.168.1.32、33、35）执行如下启动命令</span></span><br><span class="line">docker run --name shardsvr3 -d -p 9007:27018 \</span><br><span class="line">  --entrypoint <span class="string">&quot;mongod&quot;</span> \</span><br><span class="line">  -v /data/mongod/shard3:/home/mongod \</span><br><span class="line">  -v /data/mongod/conf/keyfile/:/data/keyfile/ \</span><br><span class="line">  -v /data/mongod/conf/shard3/:/data/conf/ \</span><br><span class="line">  mongo:4.0.21 -f /data/conf/mongod.conf</span><br></pre></td></tr></table></figure>
<h3 id="2、初始化分片服务器-2"><a href="#2、初始化分片服务器-2" class="headerlink" title="2、初始化分片服务器"></a>2、初始化分片服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录进容器中,任意节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it shardsvr3 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录分片服务器</span></span><br><span class="line"><span class="comment"># 192.168.1.32 副分片节点</span></span><br><span class="line"><span class="comment"># 192.168.1.33 仲裁分片节点</span></span><br><span class="line"><span class="comment"># 192.168.1.35 主分片节点</span></span><br><span class="line"></span><br><span class="line">mongo --host 192.168.1.35 --port 9007    // 尽量在主节点执行，否则可能会出现报错</span><br><span class="line">use admin</span><br><span class="line">rs.initiate(</span><br><span class="line">    &#123;</span><br><span class="line">        _id : <span class="string">&quot;rs_shardsvr3&quot;</span>,</span><br><span class="line">        members: [</span><br><span class="line">            &#123; _id : 0, host : <span class="string">&quot;192.168.1.32:9007&quot;</span>,priority:3 &#125;,</span><br><span class="line">            &#123; _id : 1, host : <span class="string">&quot;192.168.1.33:9007&quot;</span>,arbiterOnly:<span class="literal">true</span> &#125;,</span><br><span class="line">            &#123; _id : 2, host : <span class="string">&quot;192.168.1.35:9007&quot;</span>,priority:5 &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#rs.status() 查看状态</span></span><br></pre></td></tr></table></figure>

<h1 id="四，创建mongos，连接mongos到分片集群"><a href="#四，创建mongos，连接mongos到分片集群" class="headerlink" title="四，创建mongos，连接mongos到分片集群"></a>四，创建mongos，连接mongos到分片集群</h1><h2 id="创建mongos配置文件"><a href="#创建mongos配置文件" class="headerlink" title="创建mongos配置文件"></a>创建mongos配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /data/mongod/conf/mongos -p   //三台主机都执行</span><br><span class="line"></span><br><span class="line">vim /data/mongod/conf/mongos/mongod.conf</span><br><span class="line"><span class="comment">## 配置文件</span></span><br><span class="line">net:</span><br><span class="line">  bindIpAll: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">sharding: </span><br><span class="line">   configDB: rs_configsvr/192.168.1.32:9001,192.168.1.33:9001,192.168.1.35:9001   <span class="comment"># 定义为mongos配置服务器</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="mongos-部署"><a href="#mongos-部署" class="headerlink" title="mongos 部署"></a>mongos 部署</h2><h3 id="1、分片路由部署-三台均执行相同操作"><a href="#1、分片路由部署-三台均执行相同操作" class="headerlink" title="1、分片路由部署,三台均执行相同操作"></a>1、分片路由部署,三台均执行相同操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mongos -d \</span><br><span class="line">  -p 27017:27017 \</span><br><span class="line">  --entrypoint <span class="string">&quot;mongos&quot;</span> \</span><br><span class="line">  -v /data/mongod/conf/keyfile/:/data/keyfile/ \</span><br><span class="line">  -v /data/mongod/conf/mongos/:/data/conf/ \</span><br><span class="line">  mongo:4.0.21 -f /data/conf/mongod.conf</span><br></pre></td></tr></table></figure>
<p>备注：<br>rs_configsvr/192.168.1.32:9001,192.168.1.33:9001,192.168.1.35:9001: 配置服务名称/配置服务端口（多个用逗号分隔）</p>
<h3 id="2、初始化mongos"><a href="#2、初始化mongos" class="headerlink" title="2、初始化mongos"></a>2、初始化mongos</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入mongos 容器中</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mongos bash</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 连接mongos</span></span><br><span class="line">mongo --host 127.0.0.1 --port 27017</span><br><span class="line">use admin</span><br><span class="line"><span class="comment"># 添加分片服务器</span></span><br><span class="line">sh.addShard(<span class="string">&quot;rs_shardsvr1/192.168.1.32:9005,192.168.1.33:9005,192.168.1.35:9005&quot;</span>)</span><br><span class="line">sh.addShard(<span class="string">&quot;rs_shardsvr2/192.168.1.32:9006,192.168.1.33:9006,192.168.1.35:9006&quot;</span>)</span><br><span class="line">sh.addShard(<span class="string">&quot;rs_shardsvr3/192.168.1.32:9007,192.168.1.33:9007,192.168.1.35:9007&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.status() //查看状态</span><br></pre></td></tr></table></figure>

<h3 id="开启分片功能"><a href="#开启分片功能" class="headerlink" title="开启分片功能"></a>开启分片功能</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## db和collection开启分片功能</span></span><br><span class="line">虽然数据库采用分片集群的方式部署，但如果db和collection不启用分片的话（默认是不启用的），数据不会分片存储，此时如果向集群中导入一个db，会将整个db随机存储到任意一个分片中，而不是拆分存储到多个分片。</span><br><span class="line">db启用分片：</span><br><span class="line">sh.enableSharding(<span class="string">&quot;库名&quot;</span>)</span><br><span class="line">sh.enableSharding(<span class="string">&quot;&lt;database&gt;&quot;</span>)</span><br><span class="line">将上述命令中的“”换成实际的db名。</span><br><span class="line"></span><br><span class="line">collection启用分片：</span><br><span class="line">sh.shardCollection(<span class="string">&quot;库名.集合名&quot;</span>,&#123;<span class="string">&quot;key&quot;</span>:1&#125;)</span><br><span class="line">sh.shardCollection(<span class="string">&quot;&lt;database&gt;.&lt;collection&gt;&quot;</span>, &#123; &lt;shard key&gt; : <span class="string">&quot;hashed&quot;</span> &#125; )</span><br><span class="line">上述命令中的“&lt; database &gt;.&lt; collection &gt;”为实际的db名和collection名；“&#123; &lt; shard key &gt; : “hashed” &#125;”为片键的集合。</span><br></pre></td></tr></table></figure>

<h1 id="五，测试使用"><a href="#五，测试使用" class="headerlink" title="五，测试使用"></a>五，测试使用</h1><h2 id="测试使用"><a href="#测试使用" class="headerlink" title="测试使用"></a>测试使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 任意一节点操作</span></span><br><span class="line"><span class="comment"># 进入mongos 容器中</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mongos bash</span><br><span class="line"><span class="comment"># 连接mongos</span></span><br><span class="line">mongo --host 127.0.0.1 --port 27017</span><br><span class="line">use admin</span><br><span class="line"></span><br><span class="line"><span class="comment">#  testdb1开启分片功能</span></span><br><span class="line">db.runCommand( &#123; enablesharding  : <span class="string">&quot;testdb1&quot;</span>&#125;);</span><br><span class="line">db.runCommand( &#123; shardcollection : <span class="string">&quot;testdb1.tab1&quot;</span>,key : &#123;id: 1&#125; &#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加数据 </span></span><br><span class="line">use testdb1;</span><br><span class="line"><span class="keyword">for</span>(var i=1;i&lt;=20000;i++) db.tab1.save(&#123;id:i,<span class="string">&quot;test1&quot;</span>:<span class="string">&quot;testval1&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">db.tab1.stats();</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用testdb1库</span></span><br><span class="line"><span class="comment"># 循环插入数据到testdb1库的tab1集合中的键id中</span></span><br><span class="line"><span class="comment"># 该库对应的该集合对应的该键被设置成了分片</span></span><br><span class="line"><span class="comment"># 查看分片情况</span></span><br></pre></td></tr></table></figure>

<p>分别在三个主机上操作配置库、插入测试数据、查看测试数据<br>验证了副本同步，最后的显示结果看到 “sharded” : true 表示分片也是成功的</p>
<h1 id="六、开启登录认证"><a href="#六、开启登录认证" class="headerlink" title="六、开启登录认证"></a>六、开启登录认证</h1><h2 id="设置数据库账号"><a href="#设置数据库账号" class="headerlink" title="设置数据库账号"></a>设置数据库账号</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在任意mongos节点操作</span><br><span class="line"><span class="comment"># 进入mongos 容器中</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mongos bash</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 连接mongos</span></span><br><span class="line">mongo --host 127.0.0.1 --port 27017</span><br><span class="line">mongos&gt; use admin</span><br><span class="line">switched to db admin    </span><br><span class="line">mongos&gt; show collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">添加两个管理员账号,一个系统管理员:system 一个数据库管理员:administrator</span><br><span class="line">＃先添加系统管理员账号,用来管理用户</span><br><span class="line">mongos&gt; db.createUser(&#123;user:<span class="string">&quot;system&quot;</span>,<span class="built_in">pwd</span>:<span class="string">&quot;123456&quot;</span>,roles:[&#123;role:<span class="string">&quot;root&quot;</span>,db:<span class="string">&quot;admin&quot;</span>&#125;]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加数据库管理员,用来管理所有数据库</span></span><br><span class="line">mongos&gt; db.createUser(&#123;user:<span class="string">&#x27;administrator&#x27;</span>, <span class="built_in">pwd</span>:<span class="string">&#x27;123456&#x27;</span>, roles:[&#123; role: </span><br><span class="line">mongos&gt; db.auth(<span class="string">&#x27;administrator&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>)    //添加管理员用户认证,认证之后才能管理所有数据库   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出，用刚才创建的账号进行登录</span></span><br><span class="line"> mongo 192.168.1.33:27017 -u system -p 123456 --authenticationDatabase admin</span><br><span class="line"> mongo 192.168.1.35:27017 -u administrator -p 123456  --authenticationDatabase admin</span><br></pre></td></tr></table></figure>

<h2 id="开启登录验证"><a href="#开启登录验证" class="headerlink" title="开启登录验证"></a>开启登录验证</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /data/mongod/conf/keyfile -p     //三台主机都执行</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在192.168.1.32节点服务器上操作</span></span><br><span class="line"><span class="built_in">cd</span> /data/mongod/conf/keyfile           //切换到指定目录</span><br><span class="line">openssl rand -base64 756 &gt; key.file    //创建一个 keyfile(使用 openssl 生成 756 位 base64 加密的字符串)   </span><br><span class="line">chmod 600 ./key.file </span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制文件到其他主机</span></span><br><span class="line">scp ./key.file root@192.168.1.33:/data/mongod/conf/keyfile</span><br><span class="line">scp ./key.file root@192.168.1.33:/data/mongod/conf/keyfile</span><br></pre></td></tr></table></figure>
<h2 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使用访问控制强制重新启动复制集的每个成员</span><br><span class="line"><span class="comment"># 依次在每台机器上的mongod（注意是所有的mongod不是mongos）的配置文件中加入下面一段配置。如我在192.168.1.32上的config server，shard1，shard2，shard3都加入下面的配置文件</span></span><br><span class="line">security:</span><br><span class="line">  keyFile: /data/keyfile/key.file</span><br><span class="line">  authorization: enabled</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 依次在每台机器上的mongos配置文件中加入下面一段配置</span></span><br><span class="line">security:</span><br><span class="line">  keyFile: /data/keyfile/key.file</span><br></pre></td></tr></table></figure>
<h2 id="重启集群"><a href="#重启集群" class="headerlink" title="重启集群"></a>重启集群</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在三台主机执行如下命令</span></span><br><span class="line">docker ps  |grep mongo |awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> |xargs -r docker restart</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>应用部署</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>Dokcer 部署RabbitMQ集群-镜像模式（实战）</title>
    <url>/2021/02/25/rabbitmq-mirror/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="RabbiMQ模式"><a href="#RabbiMQ模式" class="headerlink" title="RabbiMQ模式"></a>RabbiMQ模式</h2><p>RabbitMQ模式大概分为以下三种:</p>
<ol>
<li>单一模式。</li>
<li>普通模式(默认的集群模式)。</li>
<li>镜像模式(把需要的队列做成镜像队列，存在于多个节点，属于RabbiMQ的HA方案，在对业务可靠性要求较高的场合中比较适用)。</li>
</ol>
<h2 id="RabbiMQ模式详解"><a href="#RabbiMQ模式详解" class="headerlink" title="RabbiMQ模式详解"></a>RabbiMQ模式详解</h2><p> abbitmq普通集群模式，是将交换机、绑定、队列的元数据复制到集群里的任何一个节点，但队列内容只存在于特定的节点中，客户端通过连接集群中任意一个节点，即可以生产和消费集群中的任何队列内容（因为每个节点都有集群中所有队列的元数据信息，如果队列内容不在本节点，则本节点会从远程节点获取内容，然后提供给消费者消费）。<br>   从该模式不难看出，普通集群可以让不同的繁忙队列从属于不同的节点，这样可以减轻单节点的压力，提升吞吐量，但是普通集群不能保证队列的高可用性，因为一旦队列所在节点宕机直接导致该队列无法使用，只能等待重启，所以要想在队列节点宕机或故障也能正常使用，就要复制队列内容到集群里的每个节点，需要创建镜像队列。<br>  rabbitmq镜像集群依赖于普通集群，所以需要先搭建rabbitmq普通集群。</p>
<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>要实现镜像模式，需要先搭建一个普通集群模式，在这个模式的基础上再配置镜像模式以实现高可用，本次实践部署rabbitmq采用的版本（rabbitmq:3.8.7-management）。</p>
<h3 id="主机列表"><a href="#主机列表" class="headerlink" title="主机列表"></a>主机列表</h3><table>
<thead>
<tr>
<th>主机</th>
<th>节点模式</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.1.32</td>
<td>磁盘节点</td>
</tr>
<tr>
<td>192.168.1.33</td>
<td>内存节点</td>
</tr>
<tr>
<td>192.168.1.35</td>
<td>内存节点</td>
</tr>
</tbody></table>
<h1 id="部署RabbitMQ"><a href="#部署RabbitMQ" class="headerlink" title="部署RabbitMQ"></a>部署RabbitMQ</h1><h2 id="1-创建持久数据目录"><a href="#1-创建持久数据目录" class="headerlink" title="1.创建持久数据目录"></a>1.创建持久数据目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /data/rabbitmq -p   //三台主机均执行</span><br></pre></td></tr></table></figure>

<h2 id="2-host配置-rabbitmq集群需要解析主机名"><a href="#2-host配置-rabbitmq集群需要解析主机名" class="headerlink" title="2.host配置(rabbitmq集群需要解析主机名)"></a>2.host配置(rabbitmq集群需要解析主机名)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/rabbitmq</span><br><span class="line">vim hosts</span><br><span class="line"><span class="comment"># hosts 内容</span></span><br><span class="line">192.168.1.32 rabbit1</span><br><span class="line">192.168.1.33 rabbit2</span><br><span class="line">192.168.1.35 rabbit3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-创建容器"><a href="#3-创建容器" class="headerlink" title="3.创建容器"></a>3.创建容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always \</span><br><span class="line">  --net host \</span><br><span class="line">  --hostname rabbit1 \</span><br><span class="line">  --name rabbit1  \</span><br><span class="line">  -v /data/rabbitmq:/var/lib/rabbitmq \</span><br><span class="line">  -v /data/rabbitmq/hosts:/etc/hosts \</span><br><span class="line">  -e RABBITMQ_ERLANG_COOKIE=<span class="string">&#x27;secret cookie here&#x27;</span> \</span><br><span class="line">  rabbitmq:3.8.7-management</span><br><span class="line">  </span><br><span class="line">  docker run -d --restart=always \</span><br><span class="line">  --net host \</span><br><span class="line">  --hostname rabbit2 \</span><br><span class="line">  --name rabbit2  \</span><br><span class="line">  -v /data/rabbitmq:/var/lib/rabbitmq \</span><br><span class="line">  -v /data/rabbitmq/hosts:/etc/hosts \</span><br><span class="line">  -e RABBITMQ_ERLANG_COOKIE=<span class="string">&#x27;secret cookie here&#x27;</span> \</span><br><span class="line">  rabbitmq:3.8.7-management</span><br><span class="line">  </span><br><span class="line">  docker run -d --restart=always \</span><br><span class="line">  --net host \</span><br><span class="line">  --hostname rabbit3 \</span><br><span class="line">  --name rabbit3  \</span><br><span class="line">  -v /data/rabbitmq:/var/lib/rabbitmq \</span><br><span class="line">  -v /data/rabbitmq/hosts:/etc/hosts \</span><br><span class="line">  -e RABBITMQ_ERLANG_COOKIE=<span class="string">&#x27;secret cookie here&#x27;</span> \</span><br><span class="line">  rabbitmq:3.8.7-management</span><br><span class="line"></span><br><span class="line">注意：hostname 不要重复</span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-d</span><br><span class="line"><span class="comment">#容器后台运行</span></span><br><span class="line">--restart=always</span><br><span class="line"><span class="comment"># 容器重启策略, always 在容器退出时总是重启容器</span></span><br><span class="line">--net host</span><br><span class="line"><span class="comment">#容器和宿主机共用网络(注意端口冲突)</span></span><br><span class="line">--hostname rabbit1</span><br><span class="line"><span class="comment">#容器的主机名为 rabbit1，容器内部的hostname</span></span><br><span class="line">--name rabbit1</span><br><span class="line"><span class="comment">#容器名为rabbit1，在宿主机上运行“docker ps”命令时显示的名称</span></span><br><span class="line">-v /data/rabbitmq:/var/lib/rabbitmq</span><br><span class="line"><span class="comment">#将宿主机目录/data/rabbitmq挂载到容器的/var/lib/rabbitmq目录</span></span><br><span class="line">-v /data/rabbitmq/hosts:/etc/hosts</span><br><span class="line"><span class="comment">#将宿主机目录/data/rabbitmq/hosts文件挂载到容器的/etc/hosts文件</span></span><br><span class="line">-e RABBITMQ_DEFAULT_USER=user01</span><br><span class="line"><span class="comment">#设置rabbitmq默认用户为user01</span></span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=password01</span><br><span class="line"><span class="comment">#设置rabbitmq默认密码为password01</span></span><br><span class="line">-e RABBITMQ_ERLANG_COOKIE=<span class="string">&#x27;secret cookie&#x27;</span></span><br><span class="line"><span class="comment">#设置rabbitmq的cookie为“secret cookie”，可以自定义为其他文本，三个容器保持一致即可。</span></span><br><span class="line">rabbitmq:3.8.7-management</span><br><span class="line"><span class="comment">#使用rabbitmq:3.8.7-management这个镜像</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>三台机器都执行上面的命令,hostname和容器name需要修改</p>
<h2 id="4-将节点2-3加入集群"><a href="#4-将节点2-3加入集群" class="headerlink" title="4.将节点2,3加入集群"></a>4.将节点2,3加入集群</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在rabbit2机器进入容器的命令行</span><br><span class="line">docker <span class="built_in">exec</span> -it rabbit2 /bin/bash</span><br><span class="line">加入集群</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl join_cluster rabbit@rabbit1</span><br><span class="line">rabbitmqctl join_cluster rabbit@rabbit1 --ram  //表示该节点为内存节点，默认为磁盘节点。</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">rabbit3执行相同的命令</span><br><span class="line"></span><br><span class="line">查询集群状态</span><br><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure>
<h3 id="特别说明："><a href="#特别说明：" class="headerlink" title="特别说明："></a>特别说明：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在上述部署已完成的情况下更改节点模式(硬盘模式-disc、内存模式-ram)</span></span><br><span class="line"><span class="comment"># 更改节点: rabbit@rabbit2为硬盘模式,操作如下：</span></span><br><span class="line"><span class="comment"># 进入任意容器内</span></span><br><span class="line">rabbitmqctl -n rabbit@rabbit2 stop_app</span><br><span class="line">rabbitmqctl -n rabbit@rabbit2 change_cluster_node_type disc</span><br><span class="line">rabbitmqctl -n rabbit@rabbit2 start_app</span><br></pre></td></tr></table></figure>

<h2 id="5-配置镜像集群策略"><a href="#5-配置镜像集群策略" class="headerlink" title="5. 配置镜像集群策略"></a>5. 配置镜像集群策略</h2><h3 id="登录管理页面"><a href="#登录管理页面" class="headerlink" title="登录管理页面"></a>登录管理页面</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">新添加用户</span><br><span class="line">rabbitmqctl list_users     //查看用户列表</span><br><span class="line">rabbitmqctl add_user admin 123456   //新增用户、密码</span><br><span class="line">rabbitmqctl set_user_tags admin administrator  // 设置admin用户标记，administrator表示最高权限</span><br><span class="line">rabbitmqctl set_permissions -p <span class="string">&quot;/&quot;</span> admin <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span>   //设置权限</span><br></pre></td></tr></table></figure>

<h3 id="开启镜像集群模式"><a href="#开启镜像集群模式" class="headerlink" title="开启镜像集群模式"></a>开启镜像集群模式</h3><p>搭建镜像集群是在web控制台完成的，主要操作就是在Admin界面添加一个Policy<br>添加策略：登录rabbitmq管理页面 ——&gt; Admin ——&gt; Policies ——&gt; Add / update a policy，填写对应的镜像策略。<br><img src="https://img-blog.csdnimg.cn/20201211085637579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDA4Mjk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201211085651109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDA4Mjk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Policy参数含义</span><br><span class="line">pattern: 队列名字的通配符 或者 ^ 匹配符，只有一个^代表匹配所有</span><br><span class="line">ha-mode：镜像队列提供了三种模式：</span><br><span class="line">        all：全部的节点队列都做镜像；</span><br><span class="line">        exactly：指定镜像队列的节点最高镜像数量；</span><br><span class="line">        nodes：只为指定具体节点配置镜像队列；</span><br><span class="line">ha-sync-mode ：节点之前的同步模式。有自动和手动两种，默认是手动，这里设置为自动。</span><br></pre></td></tr></table></figure>

<p>设置完成并添加了这个策略后，新建的和已存在的队列默认会支持此策略。</p>
<p>出现如下图所示，表示配置完成<br><img src="https://img-blog.csdnimg.cn/20201211085710284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDA4Mjk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>到此，镜像集群部署工作完成。</p>
<h1 id="RabbitMQ监控"><a href="#RabbitMQ监控" class="headerlink" title="RabbitMQ监控"></a>RabbitMQ监控</h1><p>使用两种流行的工具介绍RabbitMQ监视： Prometheus，一个监视工具包；和Grafana，一个度量可视化系统。<br>从3.8.0版开始，RabbitMQ附带了内置的Prometheus＆Grafana支持。<br>Rabbitmq_prometheus插件随附了对Prometheus度量标准收集器的支持。该插件以Prometheus文本格式在专用TCP端口上公开所有RabbitMQ指标。<br>这些度量标准提供了对RabbitMQ节点状态和运行时的深入了解。他们使有关RabbitMQ的行为，使用它的应用程序以及各种基础结构元素的推理变得更加明智。</p>
<h2 id="启用rabbitmq-prometheus"><a href="#启用rabbitmq-prometheus" class="headerlink" title="启用rabbitmq_prometheus"></a>启用rabbitmq_prometheus</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在所有节点上启用rabbitmq_prometheus 插件</span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_prometheus</span><br></pre></td></tr></table></figure>

<p>获取指标，如下所示有监控指标出现，即表示监控插件开启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s localhost:15692/metrics | head -n 3</span><br><span class="line"><span class="comment"># TYPE erlang_mnesia_held_locks gauge</span></span><br><span class="line"><span class="comment"># HELP erlang_mnesia_held_locks Number of held locks.</span></span><br><span class="line">erlang_mnesia_held_locks 0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>应用部署</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd数据备份与恢复</title>
    <url>/2021/02/26/k8s/etcd%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<span id="more"></span>

<p>对 Etcd 数据进行备份及恢复，Etcd官方也提供了备份的文档，你有兴趣可以阅读一下。这里总结了一些实际操作，以便你后续可以借鉴并进行手动的备份和恢复。命令行里面的一些证书路径以及 endpoint 地址需要根据自己的集群参数进行更改。</p>
<h1 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h1><pre><code>ETCDCTL_API=3 etcdctl --endpoints=https://127.0.0.1:2379 \
--cacert=/etc/kubernetes/pki/etcd/ca.crt \
--key=/etc/kubernetes/pki/etcd/peer.key \
--cert=/etc/kubernetes/pki/etcd/peer.crt \
snapshot save ./new.snapshot.db
</code></pre>
<h1 id="查看-etcd-集群的节点"><a href="#查看-etcd-集群的节点" class="headerlink" title="查看 etcd 集群的节点"></a>查看 etcd 集群的节点</h1><pre><code>ETCDCTL_API=3 etcdctl --endpoints=https://127.0.0.1:2379 \ 
--cacert=/etc/kubernetes/pki/etcd/ca.crt \ 
--cert=/etc/kubernetes/pki/etcd/peer.crt \ 
--key=/etc/kubernetes/pki/etcd/peer.key \
member list
</code></pre>
<h1 id="停止所有节点上的-etcd！（注意是所有！！）"><a href="#停止所有节点上的-etcd！（注意是所有！！）" class="headerlink" title="停止所有节点上的 etcd！（注意是所有！！）"></a>停止所有节点上的 etcd！（注意是所有！！）</h1><pre><code>## 如果是 static pod，可以听过如下的命令进行 stop
## 如果是 systemd 管理的，可以通过 systemctl stop etcd
mv /etc/kubernetes/manifests/etcd.yaml /etc/kubernetes/
</code></pre>
<h1 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h1><p>依次在每个节点上，移除 etcd 数据</p>
<pre><code>rm -rf /var/lib/etcd
</code></pre>
<h1 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h1><pre><code>## 依次在每个节点上，恢复 etcd 旧数据
## 里面的 name，initial-advertise-peer-urls，initial-cluster=controlplane
## 等参数，可以从 etcd pod 的 yaml 文件中获取到。
ETCDCTL_API=3 etcdctl snapshot restore ./old.snapshot.db \
--data-dir=/var/lib/etcd \
--name=controlplane \
--initial-advertise-peer-urls=https://172.17.0.18:2380 \
--initial-cluster=controlplane=https://172.17.0.18:2380
</code></pre>
<h1 id="恢复-etcd-服务"><a href="#恢复-etcd-服务" class="headerlink" title="恢复 etcd 服务"></a>恢复 etcd 服务</h1><pre><code>## 依次在每个节点上，拉起 etcd 服务
mv /etc/kubernetes/etcd.yaml /etc/kubernetes/manifests/
systemctl restart kubelet
</code></pre>
<p>上述这些备份，都需要手动运行命令行进行操作。如果你的 Etcd 集群是运行在 Kubernetes 集群中的，你可以通过以下的定时 Job (CronJob) 来帮你自动化、周期性（如下的 YAML 文件中会每分钟对 Etcd 进行一次备份）地备份 Etcd 的数据。</p>
<pre><code>apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: backup
  namespace: kube-system
spec:
  # activeDeadlineSeconds: 100
  schedule: &quot;*/1 * * * *&quot;
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: backup
            image: k8s.gcr.io/etcd:3.2.24
            env:
            - name: ETCDCTL_API
              value: &quot;3&quot;
            command: [&quot;/bin/sh&quot;]
            args: [&quot;-c&quot;, &quot;etcdctl --endpoints=https://127.0.0.1:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/healthcheck-client.crt --key=/etc/kubernetes/pki/etcd/healthcheck-client.key snapshot save /backup/etcd-snapshot-$(date +%Y-%m-%d_%H:%M:%S_%Z).db&quot;]
            volumeMounts:
            - mountPath: /etc/kubernetes/pki/etcd
              name: etcd-certs
              readOnly: true
            - mountPath: /backup
              name: backup
          restartPolicy: OnFailure
          hostNetwork: true
          volumes:
          - name: etcd-certs
            hostPath:
              path: /etc/kubernetes/pki/etcd
              type: DirectoryOrCreate
          - name: backup
            hostPath:
              path: /data/backup
              type: DirectoryOrCreate
</code></pre>
]]></content>
      <categories>
        <category>Kubernetes专栏</category>
      </categories>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes Pod 故障归类与排查方法</title>
    <url>/2021/02/26/k8s/pod%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<span id="more"></span>
<pre><code>本文转载：https://cloud.tencent.com/developer/article/1638788
</code></pre>
<h1 id="Pod-概念"><a href="#Pod-概念" class="headerlink" title="Pod 概念"></a>Pod 概念</h1><p>Pod是kubernetes集群中最小的部署和管理的基本单元，协同寻址，协同调度。<br>Pod是一个或多个容器的集合，是一个或一组服务（进程）的抽象集合。<br>Pod中可以共享网络和存储（可以简单理解为一个逻辑上的虚拟机，但并不是虚拟机）。<br>Pod被创建后用一个UID来唯一标识，当Pod生命周期结束，被一个等价Pod替代，UID将重新生成。<br>Docker 是 Kubernetes Pod 中最常用的容器运行时，但 Pod 也能支持其他的容器运行，比如 rkt、podman等。<br>Kubernetes 集群中的 Pod 可被用于以下两个主要用途：<br>运行单个容器的 Pod。“每个 Pod 一个容器”模型是最常见的 Kubernetes 用例；在这种情况下，可以将 Pod 看作单个容器的包装器，并且 </p>
<p>   Kubernetes 直接管理 Pod，而不是容器。<br>运行多个协同工作的容器的 Pod。 Pod 可能封装由多个紧密耦合且需要共享资源的共处容器组成的应用程序。 这些位于同一位置的容器可能形成单个内聚的服务单元，一个容器将文件从共享卷提供给公众，而另一个单独的“挂斗”容器则刷新或更新这些文件。 Pod 将这些容器和存储资源打包为一个可管理的实体。</p>
<h1 id="Pod-控制器"><a href="#Pod-控制器" class="headerlink" title="Pod 控制器"></a>Pod 控制器</h1><p>控制器可以为您创建和管理多个 Pod，管理副本和上线，并在集群范围内提供自修复能力。 例如，如果一个节点失败，控制器可以在不同的节点上调度一样的替身来自动替换 Pod。<br>包含一个或多个 Pod 的控制器一些示例包括：<br>Deployment kubernetes中最常用的控制器，用于运行无状态应用<br>StatefulSet 用于运行有状态应用<br>DaemonSet 作用就像是计算机中的守护进程，它能够运行集群存储、日志收集和监控等『守护进程』<br>控制器通常使用您提供的 Pod 模板来创建它所负责的 Pod。</p>
<h1 id="Pod-故障归类"><a href="#Pod-故障归类" class="headerlink" title="Pod 故障归类"></a>Pod 故障归类</h1><p>Pod状态 一直处于 Pending<br>Pod状态 一直处于 Waiting<br>Pod状态 一直处于 ContainerCreating<br>Pod状态 处于 ImagePullBackOff<br>Pod状态 处于 CrashLoopBackOff<br>Pod状态 处于 Error<br>Pod状态 一直处于 Terminating<br>Pod状态 处于 Unknown<br>上面是个人总结，如果不全请见谅！</p>
<h1 id="Pod-排查故障命令"><a href="#Pod-排查故障命令" class="headerlink" title="Pod 排查故障命令"></a>Pod 排查故障命令</h1><pre><code>kubectl get pod &lt;pod-name&gt; -o yaml # 查看 Pod 配置是否正确
kubectl describe pod &lt;pod-name&gt; # 查看 Pod 详细事件信息
kubectl logs &lt;pod-name&gt; [-c &lt;container-name&gt;] # 查看容器日志
</code></pre>
<h1 id="Pod-故障问题与排查方法"><a href="#Pod-故障问题与排查方法" class="headerlink" title="Pod 故障问题与排查方法"></a>Pod 故障问题与排查方法</h1><p>Pod 一直处于 Pending 状态<br>Pending状态，这个状态意味着，Pod 的 YAML 文件已经提交给 Kubernetes，API 对象已经被创建并保存在 Etcd 当中。但是，这个 Pod 里有些容器因为某种原因而不能被顺利创建。比如，调度不成功（可以通过 kubectl describe pod 命令查看到当前 Pod 的事件，进而判断为什么没有调度）。可能原因： 资源不足（集群内所有的 Node 都不满足该 Pod 请求的 CPU、内存、GPU 等资源）；HostPort 已被占用（通常推荐使用 Service 对外开放服务端口）。<br>Pod 一直处于 Waiting 或 ContainerCreating 状态<br>首先还是通过 kubectl describe pod 命令查看到当前 Pod 的事件。可能的原因包括：<br>1、镜像拉取失败，比如，镜像地址配置错误、拉取不了国外镜像源（gcr.io）、私有镜像密钥配置错误、镜像太大导致拉取超时（可以适当调整 kubelet 的 –image-pull-progress-deadline 和 –runtime-request-timeout 选项）等。<br>2、CNI 网络错误，一般需要检查 CNI 网络插件的配置，比如：无法配置 Pod 网络、无法分配 IP 地址。<br>3、容器无法启动，需要检查是否打包了正确的镜像或者是否配置了正确的容器参数。<br>4、Failed create pod sandbox，查看kubelet日志，原因可能是磁盘坏道（input/output error）。</p>
<h2 id="Pod-一直处于-ImagePullBackOff-状态"><a href="#Pod-一直处于-ImagePullBackOff-状态" class="headerlink" title="Pod 一直处于 ImagePullBackOff 状态"></a>Pod 一直处于 ImagePullBackOff 状态</h2><p>通常是镜像名称配置错误或者私有镜像的密钥配置错误导致。这种情况可以使用 docker pull 来验证镜像是否可以正常拉取。<br>如果私有镜像密钥配置错误或者没有配置，按下面检查：</p>
<p>1、查询 docker-registry 类型的 Secret</p>
<pre><code># 查看 docker-registry Secret 
$ kubectl  get secrets my-secret -o yaml | grep &#39;dockerconfigjson:&#39; | awk &#39;&#123;print $NF&#125;&#39; | base64 -d
</code></pre>
<p>2、创建 docker-registry 类型的 Secret</p>
<pre><code># 首先创建一个 docker-registry 类型的 Secret
$ kubectl create secret docker-registry my-secret --docker-server=DOCKER_REGISTRY_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL

# 然后在 Deployment 中引用这个 Secret
spec:
  containers:
  - name: private-reg-container
    image: &lt;your-private-image&gt;
  imagePullSecrets:
  - name: my-secret
</code></pre>
<h2 id="Pod-一直处于-CrashLoopBackOff-状态"><a href="#Pod-一直处于-CrashLoopBackOff-状态" class="headerlink" title="Pod 一直处于 CrashLoopBackOff 状态"></a>Pod 一直处于 CrashLoopBackOff 状态</h2><p>CrashLoopBackOff 状态说明容器曾经启动了，但又异常退出。此时可以先查看一下容器的日志。<br>通过命令 kubectl logs 和 kubectl logs –previous 可以发现一些容器退出的原因，比如：容器进程退出、健康检查失败退出、此时如果还未发现线索，还可以到容器内执行命令来进一步查看退出原因（kubectl exec cassandra – cat /var/log/cassandra/system.log），如果还是没有线索，那就需要 SSH 登录该 Pod 所在的 Node 上，查看 Kubelet 或者 Docker 的日志进一步排查。</p>
<h2 id="Pod-处于-Error-状态"><a href="#Pod-处于-Error-状态" class="headerlink" title="Pod 处于 Error 状态"></a>Pod 处于 Error 状态</h2><p>通常处于 Error 状态说明 Pod 启动过程中发生了错误。常见的原因包括：依赖的 ConfigMap、Secret 或者 PV 等不存在；请求的资源超过了管理员设置的限制，比如超过了 LimitRange 等；违反集群的安全策略，比如违反了 PodSecurityPolicy 等；容器无权操作集群内的资源，比如开启 RBAC 后，需要为 ServiceAccount 配置角色绑定;</p>
<h2 id="Pod-处于-Terminating-或-Unknown-状态"><a href="#Pod-处于-Terminating-或-Unknown-状态" class="headerlink" title="Pod 处于 Terminating 或 Unknown 状态"></a>Pod 处于 Terminating 或 Unknown 状态</h2><p>从 v1.5 开始，Kubernetes 不会因为 Node 失联而删除其上正在运行的 Pod，而是将其标记为 Terminating 或 Unknown 状态。想要删除这些状态的 Pod 有三种方法：</p>
<p>1、从集群中删除该 Node。使用公有云时，kube-controller-manager 会在 VM 删除后自动删除对应的 Node。而在物理机部署的集群中，需要管理员手动删除 Node（如 kubectl delete node ）。</p>
<p>2、Node 恢复正常。Kubelet 会重新跟 kube-apiserver 通信确认这些 Pod 的期待状态，进而再决定删除或者继续运行这些 Pod。用户强制删除。用户可以执行 kubectl delete pods pod-name –grace-period=0 –force 强制删除 Pod。除非明确知道 Pod 的确处于停止状态（比如 Node 所在 VM 或物理机已经关机），否则不建议使用该方法。特别是 StatefulSet 管理的 Pod，强制删除容易导致脑裂或者数据丢失等问题。</p>
<p>3、Pod 行为异常，这里所说的行为异常是指 Pod 没有按预期的行为执行，比如没有运行 podSpec 里面设置的命令行参数。这一般是 podSpec yaml 文件内容有误，可以尝试使用 –validate 参数重建容器，比如:<br>kubectl delete pod mypod 和 kubectl create –validate -f mypod.yaml，也可以查看创建后的 podSpec 是否是对的，比如：kubectl get pod mypod -o yaml，修改静态 Pod 的 Manifest 后未自动重建，Kubelet 使用 inotify 机制检测 /etc/kubernetes/manifests 目录（可通过 Kubelet 的 –pod-manifest-path 选项指定）中静态 Pod 的变化，并在文件发生变化后重新创建相应的 Pod。但有时也会发生修改静态 Pod 的 Manifest 后未自动创建新 Pod 的情景，此时一个简单的修复方法是重启 Kubelet。<br>Unknown 这是一个异常状态，意味着 Pod 的状态不能持续地被 kubelet 汇报给 kube-apiserver，这很有可能是主从节点（Master 和 Kubelet）间的通信出现了问题。</p>
<p>pod 查看当前容器的日志</p>
<pre><code>kubectl logs $&#123;POD_NAME&#125; $&#123;CONTAINER_NAME&#125;
</code></pre>
<p>如果你的容器以前崩溃过，你可以用以下方法访问以前的容器的崩溃日志:</p>
<pre><code>kubectl logs --previous $&#123;POD_NAME&#125; $&#123;CONTAINER_NAME&#125;
</code></pre>
<p>或者，你也可以用exec在容器中运行命令:</p>
<pre><code>kubectl exec $&#123;POD_NAME&#125; -c $&#123;CONTAINER_NAME&#125; -- $&#123;CMD&#125; $&#123;ARG1&#125; $&#123;ARG2&#125; ... $&#123;ARGN&#125;
</code></pre>
<p>注意： -c ${CONTAINER_NAME} 是可选的。对于只包含一个容器的pod，可以忽略它。</p>
<p>例如，要查看正在运行的Cassandra pod中的日志，可以运行以下命令:</p>
<pre><code>kubectl exec cassandra -- cat /var/log/cassandra/system.log
</code></pre>
<p>如果这些方法都不起作用，你可以找到运行pod的主机，并SSH至主机。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/">https://kubernetes.io/zh/docs/concepts/workloads/pods/</a><br><a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-application/">https://kubernetes.io/docs/tasks/debug-application-cluster/debug-application/</a><br><a href="https://www.huweihuang.com/kubernetes-notes/concepts/pod/pod.html">https://www.huweihuang.com/kubernetes-notes/concepts/pod/pod.html</a><br><a href="https://blog.csdn.net/fanren224/article/details/86318921">https://blog.csdn.net/fanren224/article/details/86318921</a></p>
]]></content>
      <categories>
        <category>Kubernetes专栏</category>
      </categories>
      <tags>
        <tag>k8s,故障排查</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 命令（2）—— sed 命令</title>
    <url>/2021/03/01/linuxcdm/linux-cmd-sed/</url>
    <content><![CDATA[<span id="more"></span>
<pre><code>转载：https://blog.csdn.net/K346K346/article/details/53197905
</code></pre>
<h1 id="1-功能简介"><a href="#1-功能简介" class="headerlink" title="1.功能简介"></a>1.功能简介</h1><p>sed（Stream EDitor）是一种流文件编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（Pattern Space），接着用 sed 命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕，接着处理下一行，直到文件末尾。文件内容并没有改变，除非使用-i选项。sed 主要用来编辑一个或多个文件，简化对文件的反复操作或者用来编写转换程序等。</p>
<p>sed 功能同 awk 类似，差别在于，sed 简单，对列处理的功能要差一些，awk 功能复杂，对列处理的功能比较强大。</p>
<h1 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h1><pre><code>sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]...
</code></pre>
<p>其中 OPTION 为命令选项，script-only-if-no-other-script 为处理动作，可以由-e指定多个，input-file为输入文件，可指定多个。</p>
<h1 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h1><pre><code>选项：
-n,--quiet,--silent：使用安静模式。sed的一般用法中，所有来自STDIN的数据一般都会被打印到终端上，如果加上-n后，则只有经过sed特殊处理的那一行才会被列出来。
-e &lt;script&gt;,--expression=&lt;script&gt;：指定sed动作，可以由多个-e指定多个动作。
-f &lt;script-file&gt;,--file=&lt;script-file&gt;：直接将sed的动作写在一个文件内，-f filename则可以运行filename 内的sed动作；
-r,--regexp-extended：sed支持扩展正则表达式(默认是基础正则表达式)。
-i ：直接修改读取的文件内容，而不是输出到终端。
--help：显示帮助。
--version：显示版本。

动作说明：[n1[,n2]]function
n1, n2 ：不见得会存在，一般代表“选择进行动作的行数”，举例来说，如果我的动作是需要在 10 到 20 行之间进行，则写作“10,20动作行为”。

function：
a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
d ：删除，因为是删除啊，所以 d 后面通常不接任何内容；
i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
s ：替换，通常这个s的动作可以搭配正规表示法！例如 1,20s/old/new/g。
</code></pre>
<h1 id="4-典型示例"><a href="#4-典型示例" class="headerlink" title="4.典型示例"></a>4.典型示例</h1><h2 id="4-1-删除行操作"><a href="#4-1-删除行操作" class="headerlink" title="4.1 删除行操作"></a>4.1 删除行操作</h2><p>（1）将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除。</p>
<pre><code>[b3335@MIC ~]$ nl -n ln /etc/passwd | sed &#39;2,5d&#39;
1 root:x:0:0:root:/root:/bin/bash
6 sync:x:5:0:sync:/sbin:/bin/sync
7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
.....(后面省略).....
</code></pre>
<p>注意：原本应该是要下达 sed -e 才对，当只有一个动作的时候，没有 -e 也行，但是多于一个动作时必须要使用-e选项来指定动作。同时也要注意的是， sed 后面接的动作，请务必以两个单引号括住。</p>
<p>（2）只要删除第 2 行。</p>
<pre><code>nl /etc/passwd | sed &#39;2d&#39; 
</code></pre>
<p>（3）要删除第 3 到最后一行</p>
<pre><code>nl /etc/passwd | sed &#39;3,$d&#39; 
</code></pre>
<h2 id="4-2-新增行操作"><a href="#4-2-新增行操作" class="headerlink" title="4.2 新增行操作"></a>4.2 新增行操作</h2><p>（1）在第二行后加上”I like drinking tea”。</p>
<pre><code>[b3335@MIC ~]$ nl -n ln /etc/passwd | sed &#39;2a I like drinking tea&#39;
1    root:x:0:0:root:/root:/bin/bash
2    bin:x:1:1:bin:/bin:/sbin/nologin
I like drinking tea
3    daemon:x:2:2:daemon:/sbin:/sbin/nologin
.....(后面省略).....
</code></pre>
<p>（2）那如果是要在第二行前加入。</p>
<pre><code>nl /etc/passwd | sed &#39;2i drink tea&#39;
//或
nl /etc/passwd | sed &#39;1a drink tea&#39;
</code></pre>
<p>（3）在第二行后面加入两行，“I like drinking tea”与”I like drinking beer”。</p>
<pre><code>[b3335@MIC ~]$ nl -n ln /etc/passwd | sed &#39;2a I like drinking tea\nI like drinking beer&#39;
1         root:x:0:0:root:/root:/bin/bash
2         bin:x:1:1:bin:/bin:/sbin/nologin
I like drinking tea
I like drinking beer
3         daemon:x:2:2:daemon:/sbin:/sbin/nologin
…（后面省略）…
</code></pre>
<p>或者每一行使用反斜杠\来分开，就可以在命令行中将一条命令分开多行输入，如下：</p>
<pre><code>[b3335@MIC ~]$ nl -n ln /etc/passwd | sed &#39;2a I like drinking tea\
&gt; I like drinking beer&#39;
</code></pre>
<h2 id="4-3-替换行操作"><a href="#4-3-替换行操作" class="headerlink" title="4.3 替换行操作"></a>4.3 替换行操作</h2><p>（1）将第2-5行的内容替换成为”No 2-5 number”。</p>
<pre><code>[b3335@MIC ~]$ nl -nln /etc/passwd | sed &#39;2,5c No 2-5 number&#39;
1         root:x:0:0:root:/root:/bin/bash
No 2-5 number
6         sync:x:5:0:sync:/sbin:/bin/sync
.....(后面省略).....
</code></pre>
<h2 id="4-4-选择行打印"><a href="#4-4-选择行打印" class="headerlink" title="4.4 选择行打印"></a>4.4 选择行打印</h2><p>（1）仅列出 /etc/passwd 文件内的第 5-7 行。</p>
<pre><code>[root@www ~]# nl -nln /etc/passwd | sed -n &#39;5,7p&#39;
5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
6 sync:x:5:0:sync:/sbin:/bin/sync
7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
</code></pre>
<h2 id="4-5-数据的查找并进行相关操作"><a href="#4-5-数据的查找并进行相关操作" class="headerlink" title="4.5 数据的查找并进行相关操作"></a>4.5 数据的查找并进行相关操作</h2><p>（1）数据的查找并显示<br>搜索 /etc/passwd有root关键字的行并输出。</p>
<pre><code>[b3335@MIC ~]$ nl /etc/passwd | sed -n &#39;/root/p&#39;
1    root:x:0:0:root:/root:/bin/bash
11    operator:x:11:0:operator:/root:/sbin/nologin
</code></pre>
<p>（2）数据的查找并删除<br>删除/etc/passwd所有包含root的行，其他行输出。</p>
<pre><code>[b3335@MIC ~]$ nl /etc/passwd | sed  &#39;/root/d&#39;
2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh
3  bin:x:2:2:bin:/bin:/bin/sh
…（下面忽略）…
</code></pre>
<p>如果想删除匹配的字符串，使用如下命令：</p>
<pre><code>[b3335@MIC ~]$ nl /etc/passwd | sed  &#39;s/root//g&#39;
</code></pre>
<p>（3）数据的查找并替换<br>除了整行的处理模式之外， sed 还可以用行为单位进行部分数据的搜寻并取代。基本上 sed 的搜寻与替代的与 vi 相当的类似！他有点像这样：</p>
<pre><code>sed &#39;s/被取代的字串/新的字串/g&#39;
</code></pre>
<p>（4）数据的搜寻并执行命令<br>搜索/etc/passwd,找到root对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行：</p>
<pre><code>nl /etc/passwd | sed -n &#39;/root/&#123;s/bash/blueshell/;p&#125;&#39;
1  root:x:0:0:root:/root:/bin/blueshell
</code></pre>
<p>如果只替换/etc/passwd的第一个bash关键字为blueshell，就退出</p>
<pre><code>nl /etc/passwd | sed -n &#39;/bash/&#123;s/bash/blueshell/;p;q&#125;&#39;    
1  root:x:0:0:root:/root:/bin/blueshell
</code></pre>
<h2 id="4-6-多点编辑"><a href="#4-6-多点编辑" class="headerlink" title="4.6 多点编辑"></a>4.6 多点编辑</h2><p>一条sed命令，删除/etc/passwd第三行到末尾的数据，并把bash替换为blueshell</p>
<pre><code>nl /etc/passwd | sed -e &#39;3,$d&#39; -e &#39;s/bash/blueshell/&#39;
1  root:x:0:0:root:/root:/bin/blueshell
2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh
</code></pre>
<p>-e表示多点编辑，第一个编辑命令删除/etc/passwd第三行到末尾的数据，第二条命令搜索bash替换为blueshell。</p>
<h2 id="4-7-直接修改文件"><a href="#4-7-直接修改文件" class="headerlink" title="4.7 直接修改文件"></a>4.7 直接修改文件</h2><p>sed 可以直接修改文件的内容，不必使用管道命令或数据流重导向！ 不过，由於这个动作会直接修改到原始的文件，所以请你千万不要随便拿系统配置来测试，使用时也要慎重。我们使用下载的regular_express.txt 文件来测试看看吧！</p>
<p>利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !</p>
<pre><code>[root@www ~]# sed -i &#39;s/\.$/!/g&#39; regular_express.txt
</code></pre>
<p>利用 sed 直接在 regular_express.txt 最后一行加入”# This is a test”。</p>
<pre><code>[root@www ~]# sed -i &#39;$a # This is a test&#39; regular_express.txt
</code></pre>
<p>由於 $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增”# This is a test”。</p>
<p>sed 的-i选项可以直接修改文件内容，这功能非常有帮助！举例来说，如果你有一个 100 万行的文件，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为文件太大了！那怎办？就利用 sed 啊！透过 sed 直接修改/取代的功能，你甚至不需要使用 vim 去修订！</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Linux sed命令详解<br>[2] 鸟哥.鸟哥的私房菜基础学习篇第三版[M].北京：人民邮电出版社，2010：357-360</p>
]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令（1）—— xargs</title>
    <url>/2021/03/01/linuxcdm/linux-cmd-xargs/</url>
    <content><![CDATA[<span id="more"></span>


<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">转自：恋猫大鲤鱼</span><br><span class="line">https://dablelv.blog.csdn.net/article/details/<span class="number">77151267</span></span><br></pre></td></tr></table></figure>

<h1 id="1-命令简介"><a href="#1-命令简介" class="headerlink" title="1.命令简介"></a>1.命令简介</h1><p>xargs 可以将 stdin 中以空格或换行符进行分隔的数据，形成以空格分隔的参数（arguments），传递给其他命令。因为以空格作为分隔符，所以有一些文件名或者其他意义的字符串内含有空格的时候，xargs 可能会误判。简单来说，xargs 的作用是给其他命令传递参数，是构建单行命令的重要组件之一。</p>
<p>之所以要用到 xargs，是因为很多命令不支持使用管道 | 来传递参数，例如：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">find /sbin <span class="literal">-perm</span> +<span class="number">700</span> | <span class="built_in">ls</span> <span class="literal">-l</span>         <span class="comment"># 这个命令是错误,因为标准输入不能作为ls的参数</span></span><br><span class="line">find /sbin <span class="literal">-perm</span> +<span class="number">700</span> | xargs <span class="built_in">ls</span> <span class="literal">-l</span>   <span class="comment"># 这样才是正确的</span></span><br></pre></td></tr></table></figure>

<h1 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2.命令格式"></a>2.命令格式</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">xargs [<span class="type">OPTIONS</span>] [<span class="type">COMMAND</span>]</span><br></pre></td></tr></table></figure>

<h1 id="3-选项说明"><a href="#3-选项说明" class="headerlink" title="3.选项说明"></a>3.选项说明</h1><p>注意，长选项的强制性参数对于短选项也是强制的。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="literal">-0</span>, -<span class="literal">-null</span></span><br><span class="line">	如果输入的 stdin 含有特殊字符，例如反引号 `、反斜杠 \、空格等字符时，xargs 将它还原成一般字符。为默认选项</span><br><span class="line"><span class="literal">-a</span>, -<span class="literal">-arg</span><span class="operator">-file</span>=FILE</span><br><span class="line">	从指定的文件 FILE 中读取输入内容而不是从标准输入</span><br><span class="line"><span class="literal">-d</span>, -<span class="literal">-delimiter</span>=<span class="built_in">DEL</span></span><br><span class="line">	指定 xargs 处理输入内容时的分隔符。xargs 处理输入内容默认是按空格和换行符作为分隔符，输出 arguments 时按空格分隔</span><br><span class="line"><span class="literal">-E</span> EOF_STR</span><br><span class="line">	EOF_STR 是 <span class="keyword">end</span> of file string，表示输入的结束</span><br><span class="line"><span class="literal">-e</span>, -<span class="literal">-eof</span>[=<span class="type">EOF_STR</span>]</span><br><span class="line">	作用等同于 <span class="literal">-E</span> 选项，与 <span class="literal">-E</span> 选项不同时，该选项不符合 POSIX 标准且 EOF_STR 不是强制的。如果没有 EOF_STR 则表示输入没有结束符</span><br><span class="line"><span class="literal">-I</span> REPLACE_STR</span><br><span class="line">	将 xargs 输出的每一项参数单独赋值给后面的命令，参数需要用指定的替代字符串 REPLACE_STR 代替。REPLACE_STR 可以使用 &#123;&#125; <span class="variable">$</span> <span class="selector-tag">@</span> 等符号，其主要作用是当 xargs command 后有多个参数时，调整参数位置。例如备份以 txt 为后缀的文件：find . <span class="literal">-name</span> <span class="string">&quot;*.txt&quot;</span> | xargs <span class="literal">-I</span> &#123;&#125;  <span class="built_in">cp</span> &#123;&#125; /tmp/&#123;&#125;.bak</span><br><span class="line"><span class="literal">-i</span>, -<span class="operator">-replace</span>[=<span class="type">REPLACE_STR</span>]</span><br><span class="line">	作用同 <span class="literal">-I</span> 选项，参数 REPLACE_STR 是可选的，缺省为 &#123;&#125;。建议使用 <span class="literal">-I</span> 选项，因为其符合 POSIX</span><br><span class="line"><span class="literal">-L</span> MAX_LINES</span><br><span class="line">	限定最大输入行数。隐含了 <span class="literal">-x</span> 选项</span><br><span class="line"><span class="literal">-l</span>, -<span class="literal">-max</span><span class="literal">-lines</span>[=<span class="type">MAX_LINES</span>]</span><br><span class="line">	作用同 <span class="literal">-L</span> 选项，参数 MAX_LINES 是可选的，缺省为 <span class="number">1</span>。建议使用 <span class="literal">-L</span> 选项，因为其符合 POSIX 标准</span><br><span class="line"><span class="literal">-n</span>, -<span class="literal">-max</span><span class="literal">-args</span>=MAX_ARGS</span><br><span class="line">	表示命令在执行的时候一次使用参数的最大个数</span><br><span class="line"><span class="literal">-o</span>, -<span class="literal">-open</span><span class="literal">-tty</span></span><br><span class="line">	在执行命令之前，在子进程中重新打开stdin作为/dev/TTY。如果您希望xargs运行交互式应用程序，这是非常有用的</span><br><span class="line"><span class="literal">-P</span>, -<span class="literal">-max</span><span class="literal">-procs</span>=MAX_PROCS</span><br><span class="line">	每次运行最大进程；缺省值为 <span class="number">1</span>。如果 MAX_PROCS 为 <span class="number">0</span>，xargs 将一次运行尽可能多的进程。一般和 <span class="literal">-n</span> 或 <span class="literal">-L</span> 选项一起使用</span><br><span class="line"><span class="literal">-p</span>, -<span class="literal">-interactive</span></span><br><span class="line">	当每次执行一个 argument 的时候询问一次用户</span><br><span class="line">-<span class="literal">-process</span><span class="literal">-slot</span><span class="literal">-var</span>=NAME</span><br><span class="line">	将指定的环境变量设置为每个正在运行的子进程中的唯一值。一旦子进程退出，将重用该值。例如，这可以用于初始负荷分配方案</span><br><span class="line"><span class="literal">-r</span>, -<span class="literal">-no</span><span class="literal">-run</span><span class="literal">-if</span><span class="literal">-empty</span></span><br><span class="line">	当 xargs 的输入为空的时候则停止 xargs，不用再去执行后面的命令了。为默认选项</span><br><span class="line"><span class="literal">-s</span>, -<span class="literal">-max</span><span class="literal">-chars</span>=MAX_CHARS</span><br><span class="line">	命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数，包括命令、空格和换行符。每个参数单独传入 xargs 后面的命令</span><br><span class="line">-<span class="literal">-show</span><span class="literal">-limits</span></span><br><span class="line">	显示操作系统对命令行长度的限制</span><br><span class="line"><span class="literal">-t</span>， -<span class="literal">-verbose</span></span><br><span class="line">	先打印命令到标准错误输出，然后再执行</span><br><span class="line"><span class="literal">-x</span>, -<span class="literal">-exit</span></span><br><span class="line">	配合 <span class="literal">-s</span> 使用，当命令行字符数大于 <span class="literal">-s</span> 指定的数值时，退出 xargs</span><br><span class="line">-<span class="literal">-help</span></span><br><span class="line">	显示帮助信息并退出</span><br><span class="line">-<span class="literal">-version</span></span><br><span class="line">	显示版本信息并退出</span><br></pre></td></tr></table></figure>

<h1 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h1><p>（1）将 Shell 的特殊字符反引号还原为一般字符。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;`0123`4 56789&#x27;</span> | xargs <span class="literal">-t</span> <span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> `0123`4 <span class="number">56789</span> </span><br><span class="line">`0123`4 <span class="number">56789</span></span><br></pre></td></tr></table></figure>

<p>如果直接进行如下操作，会报无法找到命令 01234 的错误，因为反引号在 Shell 中会将 01234 作为一个命令来执行，但是 01234 不是一个命令。-t 表示先打印命令，然后再执行。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> `01234` <span class="number">56789</span></span><br><span class="line"><span class="literal">-bash</span>: <span class="number">01234</span>: command not found</span><br><span class="line"><span class="number">56789</span></span><br></pre></td></tr></table></figure>
<p>（2）设置 xargs 读入参数时的结束标识，以逗号结束。这里要注意结束标志必须要是单独的字段，即以空格或者换行符分隔的字段。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="number">01234</span> , <span class="number">56789</span> | xargs <span class="literal">-E</span> <span class="string">&quot;,&quot;</span></span><br><span class="line"><span class="number">01234</span></span><br></pre></td></tr></table></figure>
<p>（3）使用 rm、mv 等命令同时操作多个文件时，有时会报 “argument list too long” 参数列表过长的错误，此时可以使用 xargs 来解决。xargs 将标准输入的字符串分隔后，作为参数传递给后面的命令。例如，给当前目录的所有文件添加后缀名。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> | xargs <span class="literal">-t</span> <span class="literal">-i</span> <span class="built_in">mv</span> &#123;&#125; &#123;&#125;.bak</span><br><span class="line"><span class="comment"># 选择符合条件的文件</span></span><br><span class="line"><span class="built_in">ls</span> | grep <span class="literal">-E</span> <span class="string">&quot;201701|201702|201703&quot;</span> | xargs <span class="literal">-I</span> &#123;&#125; <span class="built_in">mv</span> &#123;&#125; &#123;&#125;.bak</span><br></pre></td></tr></table></figure>
<p>（4）设置命令行的最大字符数。参数默认一个一个单独传入命令中执行。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;01234 56789&quot;</span> | xargs <span class="literal">-t</span> <span class="literal">-s</span> <span class="number">11</span></span><br><span class="line"><span class="built_in">echo</span> <span class="number">01234</span> </span><br><span class="line"><span class="number">01234</span></span><br><span class="line"><span class="built_in">echo</span> <span class="number">56789</span> </span><br><span class="line"><span class="number">56789</span></span><br></pre></td></tr></table></figure>

<p>（5）设置标准输入中每次多少行作为命令的参数，默认是将标准输入中所有行的归并到一行一次性传给命令执行。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="literal">-e</span> <span class="string">&quot;01234\n56789\n01234&quot;</span> | xargs <span class="literal">-t</span> <span class="literal">-L</span> <span class="number">2</span> <span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="number">01234</span> <span class="number">56789</span> </span><br><span class="line"><span class="number">01234</span> <span class="number">56789</span></span><br><span class="line"><span class="built_in">echo</span> <span class="number">01234</span> </span><br><span class="line"><span class="number">01234</span></span><br></pre></td></tr></table></figure>

<p>（6）将文件内容以空格分隔合并为一行输出。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出文件内容</span></span><br><span class="line"><span class="built_in">cat</span> test.txt</span><br><span class="line">a b c d e</span><br><span class="line">f g <span class="built_in">h</span> i j </span><br><span class="line">k l m n o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行输入合并为一行输出</span></span><br><span class="line"><span class="built_in">cat</span> test.txt | xargs</span><br><span class="line">a b c d e f g <span class="built_in">h</span> i j k l m n o</span><br></pre></td></tr></table></figure>


<p>（7）与 ps、grep、awk 和 kill 结合，强制终止指定进程。</p>
<p>ps -ef | grep spp | awk ‘{printf “%s “,$2}’ | xargs kill -9<br>1<br>ps -ef|grep spp用于查找包含 spp 的进程，awk ‘{printf “%s “,$2,FNR}将目标进程 ID 打印输出，xargs kill -9则将目标进程 ID 作为参数传递给kill -9用于杀死进程。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] xargs(1) manual<br>[2] CSDN.Xargs用法详解<br>[3] CSDN.linux xargs详解</p>
]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
